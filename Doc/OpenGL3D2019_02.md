[OpenGL 3D 2019 第02回]

# 転生したらスタックだった件

<br>

## 1 データ構造

### 1.1 いろいろなデータ構造

コンピューターはさまざまなデータを扱います。
それらを効率よく扱うために、これまたさまざまなデータの格納方法が考えられてきました。
この「データの格納方法」のことを「データ構造」と呼びます。
実際に、みなさんは普段からさまざまなデータ構造と接しています。
- 連絡先を検索する<br>
スマホなどで連絡先を検索するとき、入力に従って該当する連絡先を絞り込んでくれます。
人によっては数百に及ぶ連絡先が登録されている可能性があること、また特にスマホでは、できる限り電力を使いたくないことを考えると、これは容易ではありません。
- 文字を入力する<br>
例えば日本語には10万以上の漢字が存在すると言われており、それぞれに音読み、訓読み、さらに例外的な読み方があります。
ひらがなから瞬時に読みの一致する漢字や熟語の一覧を表示するのは、容易ではありません。
- ファイルを開く<br>
ファイル管理用のデータ構造を使って、ファイルをHDDやSSD等に保存し、検索し、開くことができます。
各々のファイルは、数百ギガバイトから数テラバイトに及ぶ容量のどこに保存されていてもおかしくありません。
数テラバイトの領域からほんの数メガバイトのファイルを探し出すのは容易ではありません。
- ウェブページを検索する<br>
インターネットには80億を越えるウェブページがあり、それぞれのページには検索対象になりうる語句が数百から数千個も含まれています。
この中から、短時間で該当する語句を含むページを探し出すことは、容易ではありません。

単純な配列では、上記の問題を解決することは不可能…とまでは言いませんが、大きな困難が予想されます。
そのため、データ構造が重要になるのです。
とはいえ、上記の問題を解決するようなデータ構造は非常に精巧かつ複雑です。
まずは簡単なデータ構造から学習していきましょう。

## 1.2 配列

C++言語において、配列とは「同じ大きさの領域を、メモリ上で連続するように割り当てたデータ構造」です。
配列は、「添字(そえじ)」を使ってアクセスできる点で、単独の変数とは異なります。
テストの得点の合計を求めるプログラムを書くとします。単独の変数を使うと以下のように書けるでしょう:
```c++
int score0 = 10;
int score1 = 3;
int score2 = 9;
int score3 = 35;
int score4 = 100;
int sum = score0 + score1 + score2 + score3 + score4;
```
この方法では、合計する得点の数が増減すると、合計を求める式も書き換えなければなりません。
これに対して、配列を使うと以下のように書けます:
```c++
int score[] = { 10, 3, 9, 35, 100 };
int sum = 0;
for (int i = 0; i < sizeof(score)/sizeof(score[0]); ++i) {
  sum += score[i];
}
```
配列バージョンでは、得点の数に増減があっても、合計を求めるプログラムを変更する必要はありません。
また、配列ではデータが順序付けされているため、「N番目の得点」といったものも簡単に調べられます。
```c++
int score[] = { 10, 3, 9, 35, 100 };
int N = 3;
int scoreN = score[N];
```
同じことを単独変数バージョンで実現するには、以下のように書くことになるでしょう:
```c++
int score0 = 10;
int score1 = 3;
int score2 = 9;
int score3 = 35;
int score4 = 100;
int N = 3;
int scoreN;
switch (N) {
  case 0: scoreN = score0; break;
  case 1: scoreN = score1; break;
  case 2: scoreN = score2; break;
  case 3: scoreN = score3; break;
  case 4: scoreN = score4; break;
}
```
単独変数バージョンでも、ポインタ演算を使って配列と同じことができると考えるかもしれません。
```c++
int N = 3;
int scoreN = *(&score0 + N);
```
しかし、これは間違いです。
なぜなら、C/C++言語の規格は、変数をメモリ上に配置する順番を決めていないからです。
あるコンパイラはscore0から順番に並べてくれるかもしれませんが、別のコンパイラはscore4から順番に並べるかもしれません。
あるいは、特に順序はなくバラバラに配置するかもしれません。
言い換えると、上のプログラムが**たまたま**うまく動いたとしても、それは偶然でしかなく保証はされない、ということです。

このように、配列というデータ構造の特徴は、「データがメモリ上に連続して配置される。それがが規格で保証されている」ことです。
この特徴が添字によるアクセスを可能にしているわけです。

# 1.3 スタック

配列は有用なデータ構造ですが、さらに工夫を加えることでもっと便利な使い方ができるようになります。
そのひとつが「スタック(stack)」というデータ構造です。スタックには「積み重ね(たモノ)」という意味があります。
「a stack of books」といえば「積み上がった本の山」を意味します。

配列をスタックに転生させるには、「いまいくつのデータを積んでいるか＝データ数」という情報を追加します。
本の山を作るには、本を積み上げていけばいいですよね。同様に、スタックでは配列の0番目の要素から順番にデータを入れていきます。
そして、データを追加するたびに、データ数を1増やします。
この操作を「スタックにデータをプッシュする」と言います。プッシュ(push)は「押す」という意味なので、データを押し込むイメージです。

また、本の山を崩すときは、上から順番に本を取っていきますよね。
同じように、スタックからデータを取り出すときは、「データ数−１」番目(これが一番上のデータです)をコピーし、データ数を1減らします。
この操作を「スタックからデータをポップする」と言います。ポップ(pop)には「物を置く、飛び出す」という意味があります。データを取り出して別の場所に置くイメージです。

配列にプッシュとポップの機能を持たせたものが「スタック」なのです。

[課題01]
新しいプロジェクトを作成し、main関数を以下のようにプログラムしてください。
そして、このプログラムが適切に動作するようなスタックを実装してください。
プッシュ操作とポップ操作は、push及びpopという名前の関数として実装してください。
```c++
#include <iostream>

int main()
{
  push(10);
  push(30);
  std::cout << pop() << "\n";
  push(20);
  push(100);
  pop();
  std::cout << pop() << "\n";
  std::cout << pop() << "\n";
}
```
正しく実装できたなら、出力は
```
30
20
10
```
になるはずです。

## 2 シーンスタック

### 2.1 シーンの切り替わりかた

シーンの切り替えには2つのパターンがあります。
ひとつは、

シーンA -> シーンB -> シーンC -> シーンD -> シーンE

というように、順次切り替えていくパターン。このパターンでは、たとえいつかシーンAに戻ることがあっても、シーンAは新しく開始されます。シーンBに切り替わる直前の状態から再開したりはしません。
そのため、前のシーンを消してしまっても問題はありません。

もうひとつは、

シーンA -> シーンB -> シーンC -> シーンB -> シーンA

というように、元のシーンに戻ってくるパターンです。このパターンでは、戻り先のシーンの状態が維持されていることが多いです。
戻り先の状態を記録しておく必要があるので、前のシーンを消すことはできません。
実はこのパターン、なんとスタックで実現することができるんです。
上記のパターンをスタック操作で表したものが次です:
```c++
push(シーンA);
push(シーンB);
push(シーンC);
pop();
pop();
```
シーンをスタックにプッシュすることで、前のシーンを残したまま次のシーンへ切り替えることが可能になります。
前のシーンに戻るには、ただポップするだけです。

### 2.2 シーンスタッククラスを定義する

それでは、シーンスタックを実装してみましょう。
まずはOpenGLのプロジェクトを開きます。そして、ソリューションエクスプローラーからScene.hを開いてください。
スタックはvectorクラスで代用できるので、まずはvectorヘッダをインクルードします。
Scene.hに次のプログラムを追加してください。
```diff
 #ifndef SCENE_H_INCLUDED
 #define SCENE_H_INCLUDED
 #include <memory>
 #include <string>
+#include <vector>

 class SceneStack;
```

ヘッダをインクルードしたら、シーンスタッククラスを定義しましょう。
ScenePtrのusing宣言の下に、次のプログラムを追加してください。
```diff
 using ScenePtr = std::shared_ptr<Scene>;

+/**
+* シーン管理クラス.
+*/
+class SceneStack
+{
+public:
+  SceneStack();
+  SceneStack(const SceneStack&) = default;
+  SceneStack& operator=(const SceneStack&) = default;
+  ~SceneStack() = default;
+
+  void Push(ScenePtr);
+  void Pop();
+  void Replace(ScenePtr);
+  Scene& Current();
+  const Scene& Current() const;
+  size_t Size() const;
+  bool Empty() const;
+
+  void Update(float);
+  void Render();
+
+private:
+  std::vector<ScenePtr> stack;
+};
+
 #endif // SCENE_H_INCLUDED
```

このクラスには、プッシュとポップだけでなく、スタックの状態にアクセスするためのメンバ関数も宣言しています。
今回の実装では、Pop関数の戻り値をvoidにしてみました。シーンの制御に関する限り、ポップしたシーンを利用することは滅多にないと思われるからです。
そのかわりに、Current(かれんと)という関数を用意して、一番上にあるシーンを参照できるようにしています。
また、見慣れないReplace(りぷれーす)関数は、ポップとプッシュを合わせたもので、前のシーンを新しいシーンに置き換えます。
これらに加えて、シーンを更新するためのUpdate(あっぷでーと)関数と、描画するためのRender(れんだー)関数も定義しました。

### 2.3 シーンスタッククラスのコンストラクタを定義する

ここからはメンバ関数の定義をしていきます。
最初はコンストラクタを定義しましょう。
Scene.cppを開き、ファイルの末尾に次のプログラムを追加してください。
```c++
/**
* コンストラクタ.
*/
SceneStack::SceneStack()
{
  stack.reserve(16);
}
```

```c++
/**
* シーンをプッシュする.
*
* @param p 新しいシーン.
*/
void SceneStack::Push(ScenePtr p)
{
  if (!stack.empty()) {
    Current().Stop();
  }
  stack.push_back(p);
  Current().Initialize();
  Current().Play();
  std::cout << "SceneStack Push: " << p->Name() << "\n";
}

```

```c++
/**
* シーンをポップする.
*/
void SceneStack::Pop()
{
  if (stack.empty()) {
    std::cout << "SceneStack Pop: [警告]シーンスタックが空です.\n";
    return;
  }
  Current().Stop();
  Current().Finalize();
  const std::string sceneName = Current().Name();
  stack.pop_back();
  if (!stack.empty()) {
    Current().Play();
  }
  std::cout << "SceneStack Pop: " << sceneName << "\n";
}

```

```c++
/**
* シーンを置き換える.
*
* @param p 新しいシーン.
*/
void SceneStack::Replace(ScenePtr p)
{
  std::string sceneName = "(Empty)";
  if (stack.empty()) {
    std::cout << "SceneStack Replace: [警告]シーンスタックが空です.\n";
  } else {
    sceneName = Current().Name();
    Current().Stop();
    Current().Finalize();
    stack.pop_back();
  }
  stack.push_back(p);
  Current().Initialize();
  Current().Play();
  std::cout << "SceneStack Replace: " << sceneName << " -> " << p->Name() << "\n";
}
```

```c++
/**
* 現在のシーンを取得する.
*
* @return 現在のシーン.
*/
Scene& SceneStack::Current()
{
  return *stack.back();
}

/**
* 現在のシーンを取得する.
*
* @return 現在のシーン.
*/
const Scene& SceneStack::Current() const
{
  return *stack.back();
}
```

```c++
/**
* シーンの数を取得する.
*
* @return スタックに積まれているシーンの数.
*/
size_t SceneStack::Size() const
{
  return stack.size();
}
```

```c++
/**
* スタックが空かどうかを調べる.
*
* @retval true  スタックは空.
* @retval false スタックに1つ以上のシーンが積まれている.
*/
bool SceneStack::Empty() const
{
  return stack.empty();
}
```

```c++
/**
* シーンを更新する.
*
* @param deltaTime 前回の更新からの経過時間(秒).
*/
void SceneStack::Update(float deltaTime)
{
  for (auto& e : stack) {
    e->Update(*this, deltaTime);
  }
}
```

```c++
/**
* シーンを描画する.
*/
void SceneStack::Render()
{
  for (auto& e : stack) {
    if (e->IsVisible()) {
      e->Render();
    }
  }
}
```














