[OpenGL 3D 2019 第02回]

# 転生したらスタックだった件

<br>

## 1 データ構造

### 1.1 いろいろなデータ構造

コンピューターはさまざまなデータを扱います。
それらを効率よく扱うために、これまたさまざまなデータの格納方法が考えられてきました。
この「データの格納方法」のことを「データ構造」と呼びます。
実際に、みなさんは普段からさまざまなデータ構造と接しています。
- 連絡先を検索する<br>
スマホなどで連絡先を検索するとき、入力に従って該当する連絡先を絞り込んでくれます。
人によっては数百に及ぶ連絡先が登録されている可能性があること、また特にスマホでは、できる限り電力を使いたくないことを考えると、これは容易ではありません。
- 文字を入力する<br>
例えば日本語には10万以上の漢字が存在すると言われており、それぞれに音読み、訓読み、さらに例外的な読み方があります。
ひらがなから瞬時に読みの一致する漢字や熟語の一覧を表示するのは、容易ではありません。
- ファイルを開く<br>
ファイル管理用のデータ構造を使って、ファイルをHDDやSSD等に保存し、検索し、開くことができます。
各々のファイルは、数百ギガバイトから数テラバイトに及ぶ容量のどこに保存されていてもおかしくありません。
数テラバイトの領域からほんの数メガバイトのファイルを探し出すのは容易ではありません。
- ウェブページを検索する<br>
インターネットには80億を越えるウェブページがあり、それぞれのページには検索対象になりうる語句が数百から数千個も含まれています。
この中から、短時間で該当する語句を含むページを探し出すことは、容易ではありません。

単純な配列では、上記の問題を解決することは不可能…とまでは言いませんが、大きな困難が予想されます。
そのため、データ構造が重要になるのです。
とはいえ、上記の問題を解決するようなデータ構造は非常に精巧かつ複雑です。
まずは簡単なデータ構造から学習していきましょう。

## 1.2 配列

C++言語において、配列とは「同じ大きさの領域を、メモリ上で連続するように割り当てたデータ構造」です。
配列は、「添字(そえじ)」を使ってアクセスできる点で、単独の変数とは異なります。
テストの得点の合計を求めるプログラムを書くとします。単独の変数を使うと以下のように書けるでしょう:
```c++
int score0 = 10;
int score1 = 3;
int score2 = 9;
int score3 = 35;
int score4 = 100;
int sum = score0 + score1 + score2 + score3 + score4;
```
この方法では、合計する得点の数が増減すると、合計を求める式も書き換えなければなりません。
これに対して、配列を使うと以下のように書けます:
```c++
int score[] = { 10, 3, 9, 35, 100 };
int sum = 0;
for (int i = 0; i < sizeof(score)/sizeof(score[0]); ++i) {
  sum += score[i];
}
```
配列バージョンでは、得点の数に増減があっても、合計を求めるプログラムを変更する必要はありません。
また、配列ではデータが順序付けされているため、「N番目の得点」といったものも簡単に調べられます。
```c++
int score[] = { 10, 3, 9, 35, 100 };
int N = 3;
int scoreN = score[N];
```
同じことを単独変数バージョンで実現するには、以下のように書くことになるでしょう:
```c++
int score0 = 10;
int score1 = 3;
int score2 = 9;
int score3 = 35;
int score4 = 100;
int N = 3;
int scoreN;
switch (N) {
  case 0: scoreN = score0; break;
  case 1: scoreN = score1; break;
  case 2: scoreN = score2; break;
  case 3: scoreN = score3; break;
  case 4: scoreN = score4; break;
}
```
単独変数バージョンでも、ポインタ演算を使って配列と同じことができると考えるかもしれません。
```c++
int N = 3;
int scoreN = *(&score0 + N);
```
しかし、これは間違いです。
なぜなら、C/C++言語の規格は、変数をメモリ上に配置する順番を決めていないからです。
あるコンパイラはscore0から順番に並べてくれるかもしれませんが、別のコンパイラはscore4から順番に並べるかもしれません。
あるいは、特に順序はなくバラバラに配置するかもしれません。
言い換えると、上のプログラムが**たまたま**うまく動いたとしても、それは偶然でしかなく保証はされない、ということです。

このように、配列というデータ構造の特徴は、「データがメモリ上に連続して配置される。それがが規格で保証されている」ことです。
この特徴が添字によるアクセスを可能にしているわけです。

# 1.3 スタック

配列は有用なデータ構造ですが、さらに工夫を加えることでもっと便利な使い方ができるようになります。
そのひとつが「スタック(stack)」というデータ構造です。スタックには「積み重ね(たモノ)」という意味があります。
「a stack of books」といえば「積み上がった本の山」を意味します。

配列をスタックに転生させるには、「いまいくつのデータを積んでいるか＝データ数」という情報を追加します。
本の山を作るには、本を積み上げていけばいいですよね。同様に、スタックでは配列の0番目の要素から順番にデータを入れていきます。
そして、データを追加するたびに、データ数を1増やします。
この操作を「スタックにデータをプッシュする」と言います。プッシュ(push)は「押す」という意味なので、データを押し込むイメージです。

また、本の山を崩すときは、上から順番に本を取っていきますよね。
同じように、スタックからデータを取り出すときは、「データ数−１」番目(これが一番上のデータです)をコピーし、データ数を1減らします。
この操作を「スタックからデータをポップする」と言います。ポップ(pop)には「物を置く、飛び出す」という意味があります。データを取り出して別の場所に置くイメージです。

配列にプッシュとポップの機能を持たせたものが「スタック」なのです。

[課題01]
新しいプロジェクトを作成し、main関数を以下のようにプログラムしてください。
そして、このプログラムが適切に動作するようなスタックを実装してください。
プッシュ操作とポップ操作は、push及びpopという名前の関数として実装してください。
```c++
#include <iostream>

int main()
{
  push(10);
  push(30);
  std::cout << pop() << "\n";
  push(20);
  push(100);
  pop();
  std::cout << pop() << "\n";
  std::cout << pop() << "\n";
}
```
正しく実装できたなら、出力は
```
30
20
10
```
になるはずです。

## 2 シーンスタック

### 2.1 シーンの切り替わりかた

シーンの切り替えには2つのパターンがあります。
ひとつは、

シーンA -> シーンB -> シーンC -> シーンD -> シーンE

というように、順次切り替えていくパターン。このパターンでは、たとえいつかシーンAに戻ることがあっても、シーンAは新しく開始されます。シーンBに切り替わる直前の状態から再開したりはしません。
そのため、前のシーンを消してしまっても問題はありません。

もうひとつは、

シーンA -> シーンB -> シーンC -> シーンB -> シーンA

というように、元のシーンに戻ってくるパターンです。このパターンでは、戻り先のシーンの状態が維持されていることが多いです。
戻り先の状態を記録しておく必要があるので、前のシーンを消すことはできません。
実はこのパターン、なんとスタックで実現することができるんです。
上記のパターンをスタック操作で表したものが次です:
```c++
push(シーンA);
push(シーンB);
push(シーンC);
pop();
pop();
```
シーンをスタックにプッシュすることで、前のシーンを残したまま次のシーンへ切り替えることが可能になります。
前のシーンに戻るには、ただポップするだけです。

### 2.2 シーンスタッククラスを定義する

それでは、シーンスタックを実装してみましょう。
まずはOpenGLのプロジェクトを開きます。そして、ソリューションエクスプローラーからScene.hを開いてください。
スタックはvectorクラスで代用できるので、まずはvectorヘッダをインクルードします。
Scene.hに次のプログラムを追加してください。
```diff
 #ifndef SCENE_H_INCLUDED
 #define SCENE_H_INCLUDED
 #include <memory>
 #include <string>
+#include <vector>

 class SceneStack;
```

ヘッダをインクルードしたら、シーンスタッククラスを定義しましょう。
ScenePtrのusing宣言の下に、次のプログラムを追加してください。
```diff
 using ScenePtr = std::shared_ptr<Scene>;

+/**
+* シーン管理クラス.
+*/
+class SceneStack
+{
+public:
+  SceneStack();
+  SceneStack(const SceneStack&) = default;
+  SceneStack& operator=(const SceneStack&) = default;
+  ~SceneStack() = default;
+
+  void Push(ScenePtr);
+  void Pop();
+  void Replace(ScenePtr);
+  Scene& Current();
+  const Scene& Current() const;
+  size_t Size() const;
+  bool Empty() const;
+
+  void Update(float);
+  void Render();
+
+private:
+  std::vector<ScenePtr> stack;
+};
+
 #endif // SCENE_H_INCLUDED
```

このクラスには、プッシュとポップだけでなく、スタックの状態にアクセスするためのメンバ関数も宣言しています。
今回の実装では、Pop関数の戻り値をvoidにしてみました。シーンの制御に関する限り、ポップしたシーンを利用することは滅多にないと思われるからです。
そのかわりに、Current(かれんと)という関数を用意して、一番上にあるシーンを参照できるようにしています。
また、見慣れないReplace(りぷれーす)関数は、ポップとプッシュを合わせたもので、前のシーンを新しいシーンに置き換えます。
これらに加えて、シーンを更新するためのUpdate(あっぷでーと)関数と、描画するためのRender(れんだー)関数も定義しました。

### 2.3 シーンスタッククラスのコンストラクタを定義する

ここからはメンバ関数の定義をしていきます。
最初はコンストラクタを定義しましょう。
Scene.cppを開き、ファイルの末尾に次のプログラムを追加してください。
```c++
/**
* コンストラクタ.
*/
SceneStack::SceneStack()
{
  stack.reserve(16);
}
```
コンストラクタでは、スタックの予約サイズを16個設定しています。
シーンを16個も積み上げることはあまりないと思うので、予約サイズとしては十分なはずです。

### 2.4 プッシュ関数を定義する

続いてプッシュ関数を定義します。
コンストラクタの定義の下に、次のプログラムを追加してください。
```diff
 SceneStack::SceneStack()
 {
   stack.reserve(16);
 }
+
+/**
+* シーンをプッシュする.
+*
+* @param p 新しいシーン.
+*/
+void SceneStack::Push(ScenePtr p)
+{
+  stack.push_back(p);
+  std::cout << "[シーン プッシュ] " << p->Name() << "\n";
+}
```
スタックとして使うだけなら、シーンポインタをプッシュするだけで終わりです。
しかし、SceneStackの実態はシーン管理クラスです。ですから、シーンを制御するプログラムを追加しましょう。
```diff
 void SceneStack::Push(ScenePtr p)
 {
+  if (!stack.empty()) {
+    Current().Stop();
+  }
+  p->Initialize();
+  p->Play();
   stack.push_back(p);
   std::cout << "[シーン プッシュ] " << p->Name() << "\n";
 }
```
最初に、スタックにシーンが積まれているかを調べ、存在していたら、現在一番上にあるシーンを停止させます。
次に、新しいシーンを初期化したのち実行開始し、このシーンをスタックにプッシュします。
現在のシーンを停止して、新しいシーンを起動しているわけです。

### 2.5 ポップ関数を定義する

次は、ポップ関数を定義します。
Push関数の定義の下に、次のプログラムを追加してください。
```diff
   stack.push_back(p);
   std::cout << "[シーン プッシュ] " << p->Name() << "\n";
 }
+
+/**
+* シーンをポップする.
+*/
+void SceneStack::Pop()
+{
+  const std::string sceneName = Current().Name();
+  stack.pop_back();
+  std::cout << "[シーン ポップ] " << sceneName << "\n";
+}
```
ポップ操作にもシーン制御プログラムを追加しましょう。
Pop関数に次のプログラムを追加してください。
```diff
 void SceneStack::Pop()
 {
+  if (stack.empty()) {
+    std::cout << "[シーン ポップ] [警告] シーンスタックが空です.\n";
+    return;
+  }
+  Current().Stop();
+  Current().Finalize();
   const std::string sceneName = Current().Name();
   stack.pop_back();
+  if (!stack.empty()) {
+    Current().Play();
+  }
   std::cout << "[シーン ポップ] " << sceneName << "\n";
 }
```
最初にスタックの状態をチェックします。スタックにひとつもシーンが積まれていないのにこの関数が呼ばれた場合、高確率でなにか良くないことが起きています。
そこで、メッセージを出力して注意を促します。そして、ポップするシーンがないのですぐにreturnします。
シーンが積まれている場合、カレント(現在一番上にある)シーンを停止、終了させます。
そしてスタックをポップし、まだシーンが積まれているようなら、新たにカレントになったシーンの実行を開始します。

> [補足]<br>
> Current(カレント)は「現在の」という意味です。

### 2.6 リプレース関数を定義する

次に、シーンを置き換える関数を定義します。
Pop関数の定義の下に、次のプログラムを追加してください。
```diff
   if (!stack.empty()) {
     Current().Play();
   }
   std::cout << "[シーン ポップ] " << sceneName << "\n";
 }
+
+/**
+* シーンを置き換える.
+*
+* @param p 新しいシーン.
+*/
+void SceneStack::Replace(ScenePtr p)
+{
+  std::string sceneName = "(Empty)";
+  if (stack.empty()) {
+    std::cout << "[シーン リプレース] [警告]シーンスタックが空です.\n";
+  } else {
+    sceneName = Current().Name();
+    Current().Stop();
+    Current().Finalize();
+    stack.pop_back();
+  }
+  stack.push_back(p);
+  Current().Initialize();
+  Current().Play();
+  std::cout << "[シーン リプレース] " << sceneName << " -> " << p->Name() << "\n";
+}
```
Replace(りぷれーす)には「取り替える、交換する」という意味があります。
この関数はその言葉のとおり、一番上に積まれたシーンを取り除き、新しいシーンを積む、という処理を行います。

### 2.7 現在のシーンを取得する関数を定義する

現在のシーンを取得する関数には、const(こんすと)の付かないバージョンと付いているバージョンがあります。
constの付いているほうは「const(こんすと)メンバ関数」と言います。付いていないほうは単に「メンバ関数」と言いますが、特にconstメンバ関数と区別したい場合は「非const(こんすと)メンバ関数」と呼びます。<br>
それでは、Replace関数の定義の下に、次のプログラムを追加してください。
```diff
   Current().Play();
   std::cout << "[シーン リプレース] " << sceneName << " -> " << p->Name() << "\n";
 }
+
+/**
+* 現在のシーンを取得する.
+*
+* @return 現在のシーン.
+*/
+Scene& SceneStack::Current()
+{
+  return *stack.back();
+}
+
+/**
+* 現在のシーンを取得する.
+*
+* @return 現在のシーン.
+*/
+const Scene& SceneStack::Current() const
+{
+  return *stack.back();
+}
```
Current関数の内容はどちらも同じものになっていて、どちらも同じback関数を呼び出しているように見えます。しかし、実は違う関数を呼び出しているのです。
std::vectorにはconstなしとありの両方のback関数が定義されていて、constのないCurrent関数では同じくconstのないback関数が呼び出され、constの付いたCrrent関数ではconstの付いたback関数が呼び出されます。
ちょっとややこしいですが、constありとなしの呼び分けはコンパイラがやってくれますので、あまり気にする必要はありません。

### 2.8 constメンバ関数の意義と注意点

constを付けて変数を定義すると、その変数を書き換えられなくなります。
それと同様に、constを付けてメンバ関数を宣言すると、そのメンバ関数内ではメンバ変数を書き換えられなくなります。
また、C++にはconstを付けた変数から呼び出せるのはconstメンバ関数だけ、というルールがあります。
もし普通のメンバ関数を呼び出せてしまうと、その中でメンバ変数を書き換えることができてしまうからです。

なんだかややこしいですが、それほど難しく考えることはありません。
constメンバ関数は、Current関数のように「何らかのデータを取得する」関数であることがほとんどだからです。
「データを取得する」という操作は、const変数に対しても使えないと困りますからね。

なお、同じ名前でconstの有無だけが違う2つの関数を定義するとき、その2つは本質的に同じ操作を行うように書くべきです。
constの有無によって行われる操作が違ってしまうと、あとから変数にconstをつけたり消したりするだけでプログラムの動作が変わってしまうからです。

いろいろと説明しましたが、とりあえずは「データを取得するメンバ関数を書くときはconstバージョンも書く」と覚えておけば十分でしょう。

### 2.9 サイズ関数を定義する

Size(さいず)関数は、シーンスタックに積まれている数を調べます。
主な用途はデバッグです。
Current関数の定義の下に、次のプログラムを追加してください。
```c++
/**
* シーンの数を取得する.
*
* @return スタックに積まれているシーンの数.
*/
size_t SceneStack::Size() const
{
  return stack.size();
}
```
### 2.10 エンプティ関数を定義する

Empty(えんぷてぃ)関数は、シーンスタックが空かどうかを調べます。
これも、主な用途はデバッグです。
Size関数の定義の下に、次のプログラムを追加してください。
```c++
/**
* スタックが空かどうかを調べる.
*
* @retval true  スタックは空.
* @retval false スタックに1つ以上のシーンが積まれている.
*/
bool SceneStack::Empty() const
{
  return stack.empty();
}
```

### 2.11 アップデート関数を定義する

Update(あっぷでーと)関数は、シーンスタックに積まれている全シーンのUpdate関数を呼び出します。
Empty関数の定義の下に、次のプログラムを追加してください。
```c++
/**
* シーンを更新する.
*
* @param deltaTime 前回の更新からの経過時間(秒).
*/
void SceneStack::Update(float deltaTime)
{
  for (auto& e : stack) {
    e->Update(*this, deltaTime);
  }
}
```

### 2.12 レンダー関数を定義する

Render(れんだー)関数は、シーンスタックに積まれているシーンのうち、表示状態になっている全てのシーンのRender関数を呼び出します。
Update関数の定義の下に、次のプログラムを追加してください。
```c++
/**
* シーンを描画する.
*/
void SceneStack::Render()
{
  for (auto& e : stack) {
    if (e->IsVisible()) {
      e->Render();
    }
  }
}
```














